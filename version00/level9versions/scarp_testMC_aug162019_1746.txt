/*
	long N;
	cout << "Number of subintervals in time: ";
	cin >> N;

	// Create the basic SDE (Context class)
	Range<double> range(0.0, cev_option.T());
	double VOld = S_0;
	double VNew = 0.0;

	std::vector<double> t_mesh = range.mesh(N);
	
	// V2 mediator stuff
	long NSim = 50000;
	cout << "Number of simulations: ";
	cin >> NSim;

	double k = cev_option.T() / double(N);
	double sqrk = sqrt(k);

	// Normal random number
	double dW;
	double price = 0.0;	// Option price

	// NormalGenerator is a base class
	// unique_ptr will manage the heap memory allocated for the random number
	std::unique_ptr<NormalGenerator> uptr_normal(new BoostNormal());

	//std::vector<double> res;
	int count = 0; // Number of times S hits origin
	double sim_price = 0.0;

	// A.
	for (long i = 1; i <= NSim; ++i)
	{ // Calculate a path at each iteration
			
		if ((i/10000) * 10000 == i)
		{// Give status after each 1000th iteration

				cout << i << endl;
		}

		VOld = S_0;
		for (unsigned long index = 1; index < t_mesh.size(); ++index)
		{
			// Create a random number
			dW = uptr_normal->getNormal();
				
			// The FDM (in this case explicit Euler)
			VNew = VOld  + (k * cev_option.drift(t_mesh[index-1], VOld))
				+ (sqrk * cev_option.diffusion(t_mesh[index-1], VOld) * dW);
			
			VOld = VNew;

			// Spurious values
			if (VNew <= 0.0) count++;
		}
			
		double tmp = cev_option.PayOff(VNew);
		price += (tmp)/double(NSim);
	}
	*/


1 factor MC with explicit Euler
Number of subintervals in time: 1000
Number of simulations: 50000
10000
20000
30000
40000
50000
Price, after discounting: 5.83591,
Number of times origin is hit: 0

C:\Users\paola\source\repos\CppFEjune2019\Level9\Level9_ExC+D_MonteCarlo-Pricing
-Methods\Release\Level9_ExC+D_MonteCarlo-Pricing-Methods.exe (process 8424) exit
ed with code 0.
To automatically close the console when debugging stops, enable Tools->Options->
Debugging->Automatically close the console when debugging stops.
Press any key to close this window . . .


/*
Study the source code in the file TestMC.cpp and relate it to the theory that we have 
just discussed. The project should contain the following source files and you need to 
set project settings in VS to point to the correct header files:
Compile and run the program as is and make sure there are no errors.

*/


/*

b) Run the MC program again with data from Batches 1 and 2. Experiment with different 
value of NT (time steps) and NSIM (simulations or draws). In particular, how many time 
steps and draws do you need in order to get the same accuracy as the exact solution? 
How is the accuracy affected by different values for NT/NSIM?
*/

/*
c) Now we do some stress-testing of the MC method. Take Batch 4. What values do we 
need to assign to NT and NSIM in order to get an accuracy to two places behind the 
decimal point? How is the accuracy affected by different values for NT/NSIM?
*/



Test Values for option pricing follows:
	Batch 1: T = 0.25, K = 65, sig = 0.30, r = 0.08, S = 60 (then C = 2.13337, P = 5.84628)
	Batch 2: T = 1.0, K = 100, sig = 0.2, r = 0.0, S = 100 (then C = 7.96557, P = 7.96557).
	Batch 3: T = 1.0, K = 10, sig = 0.50, r = 0.12, S = 5 (C = 0.204058, P = 4.07326).
	Batch 4: T = 30.0, K = 100.0, sig = 0.30, r = 0.08, S = 100.0 (C = 92.17570, P = 1.24750)
	*/

