Level2.4_Ex3 and 4

ostream with friend

Circle.h
// ostream operator <<
	friend std::ostream& operator<<(std::ostream& os, const Circle& c);

Circle.cpp

return os << "Circle with radius: " << c.m_radius
		<< ", and centrepoint: " << c.m_centrepoint;


ostream with friend
Line.h

	// ostream operator <<
	friend std::ostream& operator<<(std::ostream& os, const Line& l);

Line.cpp

return os << "Line with startpoint: " << l.m_startpoint
		<< ", and endpoint: " << l.m_endpoint;


ostream with friend

Point.h

// ostream operator <<
	friend std::ostream& operator<<(std::ostream& os, const Point& p);
};

Point.cpp

return os << "Point(" << p.m_x << ", " << p.m_y << ")";

===================================================================
===================================================================
Level2.5_Ex1: The Free Store

Line and Circle tests of yore

/*
	// overloaded operators for the Point class
	// assignment operator '='
	cout << "\n\nassignment operator '='\n\n";
	Point P3 = P1;
	// print P3
	cout << "P3 = P1: " << P3 << endl << endl;

	// assignment operator '=':	self assignment check
	cout << "\n\nassignment operator '=': no self assignment\n\n";
	P3 = P3;
	// print P3
	cout << "\nP3: " << P3 << endl << endl;

	// addition operator '+'
	cout << "\naddition operator '+'\n\n";
	Point P4 = P1 + P2;
	// print P4
	cout << "P4 = P1 + P2: " << P4 << endl;
	
	// P2 + P1
	P4 = P2 + P1;
	// print P4
	cout << "P4 = P2 + P1: " << P4 << endl << endl;
	
	// unary negation operator '-': negate the coordinates of the Point  
	cout << "\nunary operator '-': negates the coordinates of a Point\n\n";
	Point P5 = -P1;
	// print P5
	cout << "P5 = -P1: " << P5 << endl << endl;
	
	// multiplication operator '*': scaling a Point 
	cout << "\nmultiplication operator '*'\: scaling operator: Point * double\n\n";
	Point P6 = P1 * 3;
	// print P6
	cout << "P6 = P1 * 3: " << P6 << endl << endl;

	cout << "\nmultiplication operator '*': scaling operator: double * Point\n\n";
	Point P7 = 4 * P2;
	// print P7
	cout << "P7 = 4 * P2: " << P7 << endl << endl;
	
	// compound multiplication/assignment operator: scale the coordinates, then assign to the Point
	cout << "\ncompound multiplication/assignment operator '*=': scale and assign to point\n\n";
	P7 *= 4;
	// print P4
	cout << "P7 *= 4: " << P7 << endl << endl;
	
	// equality operator '==': compare Point a to Point b for equality
	cout << "\nequality operator '=='\n\n";
	Point P8 = P7;
	cout << "P7: " << P7 << ", " << "P8: " << P8 << endl;
	if (P7 == P8) { cout << "P7 and P8 share the same coordinates\n\n"; }
	else { cout << "P7 and P8 do not share the same coordinates\n\n"; }

	P8 = P6;
	cout << "P7: " << P7 << ", " << "P8: " << P8 << endl;
	if (P7 == P8) { cout << "P7 and P8 share the same coordinates\n\n"; }
	else { cout << "P7 and P8 do not share the same coordinates\n\n"; }
	
	// single argument constructor: implicit conversion operator
	Point p9{ 1.0, 1.0 };
	if (p9 == Point(1.0)) cout << "Equal!" << endl;
	else cout << "Not equal" << endl;



	
	
	cout << "\n\n"
		<< "|========================|\n"
		<< "|        LINES:          |\n"
		<< "|========================|\n\n";

	// create a line with P1 and P2: use constructor
	Line L1{ P1, P2 };

	// print L1
	cout << "Line L1: " << L1 << endl
		<< "\nL1 startpoint " << L1.StartPoint()
		<< "\nL1 endpoint " << L1.EndPoint()
		<< "\nL1 length = " << fixed << setprecision(2) 
		<< L1.Length() << endl << endl;

	// create a line with P1 and P2: use default constructor 
	Line L2;
	// set x, y coordinates with original user input values
	L2.StartPoint(P1);
	L2.EndPoint(P2);

	// print L2
	cout << "Line L2: " << L2 << endl << endl;

	// assign L1 to new L3
	Line L3 = L1;

	// print L3
	cout << "Line L3 = L1): " << L3 << endl << endl;

	// assignment operator '=': self assignment check
	L3 = L3;

	// print L3
	cout << "\nLine L3: " << L3 << endl << endl;

	
	
	cout << "\n\n"
		<< "|========================|\n"
		<< "|      CIRCLES:          |\n"
		<< "|========================|\n\n";

	// get coordinates for Point object Pc1 for Circle object C1
	geom_id = "Circle 1";
	if (!(user_input(x, geom_id, x_coord))) { return 0; }		// If user_input returns false,
	if (!(user_input(y, geom_id, y_coord))) { return 0; }		// user entered Ctrl-Z to quit
	if (!(user_input(r, geom_id, radius))) { return 0; }

	// create centre point Pc1 for C1
	Point Pc1{ x, y };
	// create Circle C1: use constructor
	Circle C1{ r, Pc1 };

	// print C1
	cout << "Circle C1: " << C1 << endl
		<< "\nC1 radius " << std::ios::fixed << setprecision(2) <<  C1.Radius()
		<< "\nC1 centrepoint " << C1.CentrePoint()
		<< "\nC1 diameter = " << C1.Diameter()
		<< "\nC1 circumference = " << C1.Circumference()
		<< "\nC1 area = " << C1.Area() << endl << endl;

	// get coordinates for Point object Pc2 for Circle object C2
	geom_id = "Circle 2";
	if (!(user_input(x, geom_id, x_coord))) { return 0; }		// If user_input returns false,
	if (!(user_input(y, geom_id, y_coord))) { return 0; }		// user entered Ctrl-Z to quit
	if (!(user_input(r, geom_id, radius))) { return 0; }

	// create centre point Pc2 for C2
	Point Pc2{ x, y };
	// create a circle, use default constructor
	Circle C2;
	// set radius, centre point with user input values
	C2.Radius(r);
	C2.CentrePoint(Pc2);

	// print C2
	cout << "Circle C2: " << C2 << endl << endl;

	// assignment operator '=': assign C1 to C3
	Circle C3 = C1;

	// print C3
	cout << "Circle C3 = C1: " << C3 << endl << endl;
	
	// assignment operator '=': self assignment check
	C3 = C3;

	// print C3
	// print C3
	cout << "Circle C3: " << C3 << endl;
	*/
===================================================================
===================================================================

/*
	do
	{
		printf("Please enter start (lower) value of the range\n");
		printf("range of values: %.1f (absolute zero) to %d\n", AbsZero, MaxRange);
		printf("Ctrl-Z to quit\n");
		
		if (fgets(input_buffer, ArSize, stdin))
		{
			start = strtof(input_buffer, &p_end);

			if (*p_end != '\n' || input_buffer[0] == '\n' || p_end == input_buffer)
			{
				//printf("ERROR: \"%s\" is an invalid float!\n", input_buffer);
				printf("ERROR: invalid entry\n\n");
				continue;
			}
			else
				break;
		}
		else
		{
			printf("Exiting...\n");
			exit(0);
		}

	} while (1);
	
	// get end value: maximum value is 1000
	do
	{
		printf("\nPlease enter end (upper) value of the range\n");
		printf("range of values: %.1f (absolute zero) to %d\n", AbsZero, MaxRange);
		printf("Ctrl-Z to quit\n");

		if (fgets(input_buffer, ArSize, stdin))
		{
			end = strtof(input_buffer, &p_end);

			if (*p_end != '\n' || input_buffer[0] == '\n' || p_end == input_buffer )
			{
				//printf("ERROR: \"%s\" is an invalid float!\n", input_buffer);
				printf("ERROR: invalid entry\n\n");
				continue;
			}
			else if (start >= end)
			{
				printf("Invalid entry: end (upper value) must be greater than start (lower value)\n");
				continue;
			}
			else
				break;
		}
		else
		{
			printf("Exiting...\n");
			exit(0);
		}

	} while (1);
	*/

	
	/*
	// maximum value for upper range = 1000
	while (1)
	{
		printf("\nPlease enter upper number of the range\n");
		printf("range: %.1f (absolute zero) to %d\n", AbsZero, MaxRange);
		scanf_s("%f", &end);
		if (end < AbsZero || end > MaxRange)
		{
			printf("Invalid entry: value out of range\n");
			continue;
		}
		else if (end <= start)
		{
			printf("Invalid entry: upper number must be greater than lower number\n");
			continue;
		}
		else
			break;
	}
	
	// step size allows for maximum 1000 steps in lower to upper range
	max_step = (end - start) / minStep;
	min_step = (end - start) / MaxRange;
	while (1)
	{
		printf("Please enter step size\n");
		printf("range: %.1f to %.1f\n", max_step, min_step);
		scanf_s("%f", &step);
		if (step < min_step || step > max_step)
		{
			printf("Invalid entry: value out of range\n");
			continue;
		}
		else
			break;
	}
	*/


/*
	for (j = 0; j < i; j++)
	{
		printf("fahrenheit array:[%d] = %.1f\n", j, fahrenheit_array[j]);
		printf("ceclius array:[%d] = %.1f\n", j, celcius_array[j]);
	}
	
	//printf("lower num: %.1f\nupper num: %.1f\nstep: %.1f\n", start, end, step);
	printf("\nStart temperarture: %.1f\n", start);
	printf("End temperarture: %.1f\n", end);
	printf("Step size: %.1f\n", step);
	*/


// building arrays in main:
// create arrays of fahrenheit temps
	stepper = start;		// initialise stepper
	
	while (stepper <= end)
	{
		fahrenheit_array[i] = stepper;
		celsius_array[i] = (fahrenheit_array[i] - 32) * fT0cRatio;
		stepper += step;
		i++;
		if (i >= MaxRange) 		// fail safe exit sequence
		{						// in case of rounding errors
			printf("Indexing Error: program exiting...");
			exit(1);
		}
	}

### user input in main


	/* If required, uncomment this and the closing comment demarcaton (line # 94)
	   to include user input

	// get user input
	// get start temperature: minimum value is -459.67, absolute zero
	get_input(p_start, input[0]);

	// get end temperature: maximum value is 1000
	do
	{
		printf("\n");
		get_input(p_end, input[1]);
		if (end > start)
			break;
		else
			printf("Invalid entry: end value must be greater than start value\n\n");
	} while (1);

	// get step size
	// step size allows for maximum 1000 steps in lower to upper range
	max_step = (end - start) / minStep;
	min_step = (end - start) / MaxRange;
	do
	{
		printf("\n");
		get_input(p_step, input[2], min_step, max_step);
		if (step > min_step && step < max_step)
			break;
		else
			printf("Invalid entry: step size out of range\n\n");
	} while (1);
	*/

###

### origina get_input() function

/*
	do
	{
		if (input_name == "step")
		{
			printf("Please enter step size\n");
			printf("range: %.1f to %.1f\n", min_step, max_step);
			printf("Ctrl-Z to quit\n");
		}
		else
		{
			printf("Please enter %s temperature\n", input_name);
			printf("range of values: %.1f (absolute zero) to %.1f\n", AbsZero, MaxRange);
			printf("Ctrl-Z to quit\n");
		}

		if (fgets(input_buffer, BufferSize, stdin))
		{
			*p_input = strtof(input_buffer, &p_end);

			if (*p_end != '\n' || input_buffer[0] == '\n' || p_end == input_buffer)
			{
				printf("ERROR: not a valid float\n\n");
				continue;
			}
			else if (*p_input < AbsZero || *p_input > MaxRange)
			{
				printf("Invalid entry: value out of range\n\n");
				continue;
			}
			else
				break;
		}
		else
		{
			printf("Exiting...\n");
			exit(0);
		}

	} while (1);
*/

###
	
Level1.4_Ex4

// - get_input() = function to get user input for start, end, and step values
//                 the function does some error checking, but needs to do much more
// - fill_array() = function to fill the fahrenheit and celsius arrays


// ostream operator <<
	//friend std::ostream& operator<<(std::ostream& os, const Point& p);